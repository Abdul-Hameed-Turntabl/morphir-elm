module Morphir.Type.Inference exposing (..)

{-| This module contains a type inference algorithm that annotates each value in the Morphir IR with type information.

Like many other functional programming languages Morphir uses a [Hindley-Milner type system][1] (aka. Damas–Milner or
Damas–Hindley–Milner). Original implementations of type inference algorithms for this class of type systems applied
unification and substitution repetitively as they traversed the expression tree (see [Algorithm W][2]). Newer
implementations (like the Haskell and Elm compilers) use a multi step approach that is more scalable because it
separates the inference from the specific language representation.

Here are some useful pointers to make it easier to understand how the algorithm works:

  - [A Type Inferencer for ML in 200 Lines of Scala – Ionuț G. Stan](https://www.youtube.com/watch?v=H7x4THVU4BQ)
      - This is a great beginner guide to understand how the algorithm works demonstrated through a simple example.
  - [Type inference as constraint solving - Simon Peyton Jones](https://www.youtube.com/watch?v=-TJGhGa04F8)
      - This is a more detailed explanation of the same algorithm which shows how the same idea scales up to the Haskell compiler.
      - It's a bit deeper but still relatively easy to follow if you have some familiarity with Haskell.

[1]: https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system
[2]: https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system#Algorithm_W
[3]: http://web.cs.ucla.edu/~palsberg/course/cs239/reading/wand87.pdf

-}

import Dict exposing (Dict)
import Morphir.IR.FQName exposing (FQName, fQName, fqn)
import Morphir.IR.Literal exposing (Literal(..))
import Morphir.IR.Name as Name
import Morphir.IR.Path as Path
import Morphir.IR.SDK.Basics exposing (boolType, floatType)
import Morphir.IR.SDK.Char exposing (charType)
import Morphir.IR.SDK.String exposing (stringType)
import Morphir.IR.Type as Type exposing (Type)
import Morphir.IR.Value as Value exposing (Value(..))
import Morphir.ListOfResults as ListOfResults
import Morphir.Type.MetaType as MetaType exposing (MetaType(..), Variable, newMetaTypeVariable, subMetaTypeVariable)


type TypeError
    = UnsolvableConstraints (List Constraint)
    | CannotUnify MetaType MetaType
    | NoSubsbstitutionFor MetaType.Variable
    | ResidualMetaVar MetaType.Variable
    | ExpectedMetaFun
    | TypeErrors (List TypeError)


inferValueTypes : Value ta va -> Result TypeError (Value ta ( Type (), va ))
inferValueTypes untypedValue =
    let
        elaboratedValue : Value ta ( MetaType.Variable, va )
        elaboratedValue =
            untypedValue
                |> assignMetaTypeVariables

        constraint : Constraint
        constraint =
            elaboratedValue
                |> generateValueConstraints
    in
    solveConstraint constraint
        |> Result.andThen
            (\substitutions ->
                applySubstitutionsToValue elaboratedValue substitutions
            )


{-| Type that represents type constraints generated by the inference algorithm based on the specific nodes in the value
IR. It's a recursive data structure so it can represent zero or many constraints. Here's an overview of the meaning of
each case:

  - **CTrue** - Represents the empty constraint. Type inference will succeed on this with no substitutions.
  - **CEqual** - Represents an equality constraint. It takes two arguments: the actual and the expected type. Both are
    represented as meta types since they can have meta type variables in them. Type inference will only succeed on this if
    the actual and the expected types are unifiable.
  - **CAnd** - Represents a conjunction of multiple constraints. Type inference will only succeeds if it succeeds on all
    constraints and the resulting substitutions will be the union of all substitutions returned by all underlying
    constraints.

-}
type Constraint
    = CTrue
    | CEqual MetaType MetaType
    | CAnd (List Constraint)


type alias Substitutions =
    Dict Variable MetaType


assignMetaTypeVariables : Value ta va -> Value ta ( MetaType.Variable, va )
assignMetaTypeVariables value =
    value
        |> Value.indexedMapValue (\index va -> ( newMetaTypeVariable index, va )) 0
        |> Tuple.first


generateValueConstraints : Value ta ( MetaType.Variable, va ) -> Constraint
generateValueConstraints value =
    case value of
        Literal ( metaTypeVariable, va ) literalValue ->
            let
                expectedType : MetaType
                expectedType =
                    case literalValue of
                        BoolLiteral _ ->
                            MetaRef (fqn "Morphir.SDK" "Basics" "Bool")

                        CharLiteral _ ->
                            MetaRef (fqn "Morphir.SDK" "Char" "Char")

                        StringLiteral _ ->
                            MetaRef (fqn "Morphir.SDK" "String" "String")

                        IntLiteral _ ->
                            Debug.todo "use number typeclass"

                        FloatLiteral _ ->
                            MetaRef (fqn "Morphir.SDK" "Basics" "Float")
            in
            CEqual (MetaVar metaTypeVariable) expectedType

        Value.Tuple ( metaTypeVariable, va ) elems ->
            let
                tupleCon : Constraint
                tupleCon =
                    CEqual
                        (MetaVar metaTypeVariable)
                        (MetaTuple (elems |> List.map (Value.valueAttribute >> Tuple.first >> MetaVar)))
            in
            CAnd (tupleCon :: (elems |> List.map generateValueConstraints))

        Value.List ( metaTypeVariable, va ) items ->
            let
                itemVar : MetaType.Variable
                itemVar =
                    metaTypeVariable
                        |> subMetaTypeVariable 1

                itemType : MetaType
                itemType =
                    MetaApply
                        (MetaRef (fqn "Morphir.SDK" "List" "List"))
                        (MetaVar itemVar)

                listCon : Constraint
                listCon =
                    CEqual
                        (MetaVar metaTypeVariable)
                        itemType

                itemCons : List Constraint
                itemCons =
                    items
                        |> List.concatMap
                            (\item ->
                                [ CEqual (MetaVar itemVar) (Value.valueAttribute item |> Tuple.first |> MetaVar)
                                , generateValueConstraints item
                                ]
                            )
            in
            CAnd (listCon :: itemCons)

        unhandled ->
            Debug.todo (Debug.toString unhandled)


solveConstraint : Constraint -> Result TypeError Substitutions
solveConstraint constraint =
    case constraint of
        CTrue ->
            Ok Dict.empty

        CEqual a b ->
            unify a b

        CAnd constraints ->
            solveConstraints constraints


solveConstraints : List Constraint -> Result TypeError Substitutions
solveConstraints constraints =
    case constraints of
        [] ->
            Ok Dict.empty

        [ constraint ] ->
            case solveConstraint constraint of
                Ok substitutions ->
                    Ok substitutions

                Err _ ->
                    Err (UnsolvableConstraints [ constraint ])

        firstConstraint :: restOfConstraints ->
            solveConstraint firstConstraint
                |> Result.andThen
                    (\firstSubstitutions ->
                        solveConstraints (applySubstitutions restOfConstraints firstSubstitutions)
                            |> Result.map (unionSubstitutions firstSubstitutions)
                    )


applySubstitutions : List Constraint -> Substitutions -> List Constraint
applySubstitutions constraints substitutions =
    constraints


unionSubstitutions : Substitutions -> Substitutions -> Substitutions
unionSubstitutions first second =
    let
        substitutedFirst : Substitutions
        substitutedFirst =
            first
                |> Dict.map (\_ metaType -> applySubstitutionsToMetaType second metaType)
    in
    Dict.union
        substitutedFirst
        second


applySubstitutionsToMetaType : Substitutions -> MetaType -> MetaType
applySubstitutionsToMetaType substitutions metaType =
    case metaType of
        MetaVar var ->
            substitutions
                |> Dict.get var
                |> Maybe.withDefault metaType

        MetaTuple metaElems ->
            MetaTuple (metaElems |> List.map (applySubstitutionsToMetaType substitutions))

        MetaApply metaFun metaArg ->
            MetaApply
                (applySubstitutionsToMetaType substitutions metaFun)
                (applySubstitutionsToMetaType substitutions metaArg)

        MetaRef _ ->
            metaType


unify : MetaType -> MetaType -> Result TypeError Substitutions
unify firstMetaType secondMetaType =
    case firstMetaType of
        MetaVar var ->
            unifyVariable var secondMetaType

        _ ->
            Err (CannotUnify firstMetaType secondMetaType)


unifyVariable : MetaType.Variable -> MetaType -> Result TypeError Substitutions
unifyVariable firstVariable secondMetaType =
    Ok (Dict.singleton firstVariable secondMetaType)


applySubstitutionsToValue : Value ta ( MetaType.Variable, va ) -> Substitutions -> Result TypeError (Value ta ( Type (), va ))
applySubstitutionsToValue value substitutions =
    let
        substitutedValue : Value ta ( Result TypeError (Type ()), va )
        substitutedValue =
            value
                |> Value.mapValueAttributes identity
                    (\( metaTypeVariable, va ) ->
                        ( substitutions
                            |> Dict.get metaTypeVariable
                            |> Result.fromMaybe (NoSubsbstitutionFor metaTypeVariable)
                            |> Result.andThen
                                (\metaType ->
                                    metaType
                                        |> metaToConcreteType
                                )
                        , va
                        )
                    )

        substitutionErrors : List TypeError
        substitutionErrors =
            substitutedValue
                |> Value.collectValueAttributes
                |> List.filterMap
                    (\( substitutionResult, _ ) ->
                        case substitutionResult of
                            Err typeError ->
                                Just typeError

                            Ok _ ->
                                Nothing
                    )
    in
    if List.isEmpty substitutionErrors then
        Ok
            (substitutedValue
                |> Value.mapValueAttributes identity
                    (\( substitutionResult, va ) ->
                        substitutionResult
                            |> Result.map (\tpe -> ( tpe, va ))
                            -- The default will never be used but needed for type-safety
                            |> Result.withDefault ( Type.Unit (), va )
                    )
            )

    else
        Err (TypeErrors substitutionErrors)


metaToConcreteType : MetaType -> Result TypeError (Type ())
metaToConcreteType metaType =
    case metaType of
        MetaVar id ->
            Err (ResidualMetaVar id)

        MetaRef fQName ->
            Ok (Type.Reference () fQName [])

        MetaTuple metaElems ->
            metaElems
                |> List.foldl
                    (\nextMetaElem elemsResultSoFar ->
                        elemsResultSoFar
                            |> Result.andThen
                                (\elemsSoFar ->
                                    metaToConcreteType nextMetaElem
                                        |> Result.map
                                            (\elem ->
                                                elem :: elemsSoFar
                                            )
                                )
                    )
                    (Ok [])
                |> Result.map (List.reverse >> Type.Tuple ())

        MetaApply _ _ ->
            let
                uncurry mt =
                    case mt of
                        MetaApply mf ma ->
                            let
                                ( f, args ) =
                                    uncurry mf
                            in
                            ( f, args ++ [ ma ] )

                        _ ->
                            ( mt, [] )

                ( metaFun, metaArgs ) =
                    uncurry metaType
            in
            case metaFun of
                MetaRef fQName ->
                    metaArgs
                        |> List.map metaToConcreteType
                        |> ListOfResults.liftAllErrors
                        |> Result.map (Type.Reference () fQName)
                        |> Result.mapError TypeErrors

                _ ->
                    Err ExpectedMetaFun
